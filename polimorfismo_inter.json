{"_id": "/activity/733edf52-8b90-11e7-9241-3401663b8331", "uri": "/activity/733edf52-8b90-11e7-9241-3401663b8331", "publisher": null, "level": "intermedio", "rights": "Attribution-ShareAlike 4.0 International", "description": "Polimorfismo e interfaces con ejemplos en c#", "icon": "file", "author": "Mario Garc\u00eda Valdez", "tags": ["clase", "csharp", "frontpage"], "image_url": null, "title": "Polimorfismo e Interfaces en C#", "type": "text", "external_url": "https://sfo2.digitaloceanspaces.com/evo/uno/autores/mario.jpg", "author_image": "https://sfo2.digitaloceanspaces.com/evo/uno/autores/mario.jpg", "content": "<p>Aunque no podemos crear objetos a partir de una interfaz, si podemos asignar\nobjetos a referencias de tipo interfaz.  La \u00fanica restricci\u00f3n es que el objeto\nen cuesti\u00f3n implemente a la interfaz. Veamos un ejemplo:</p>\n<pre><code class=\"language-csharp\">interface IFigura \n {\n  int  X { get; set; } \n  int  Y { get; set; } \n  void Dibuja();  \n  }\n</code></pre>\n<p>En este caso, para definir una figura concreta, por ejemplo un rect\u00e1ngulo,\nsimplemente implementamos a <code>IFigura</code>, incluyendo todos sus miembros en la \nclase: </p>\n<pre><code class=\"language-csharp\">class Rect\u00e1ngulo : IFigura\n{\n    private double _X, _Y;\n\n    public void Dibuja() { \n        Console.WriteLine($&quot;Se dibuja un c\u00edrculo en ({X},{Y})&quot;);\n        }\n\n    public double X{ \n        set =&gt; _X = value\n        get =&gt; _X  \n    }\n\n    public double Y {\n        set { _Y = value; }\n        get { return _Y; }\n    }\n\n    public ImprimeCoordenadas() {\n        Console.WriteLine($&quot;Mis coordenadas son: ({X},{Y})&quot;);\n    }\n}\n</code></pre>\n<p>Ahora podr\u00edamos asignar un objeto tipo <code>Rect\u00e1ngulo</code> a una referencia <code>IFigura</code>: </p>\n<pre><code class=\"language-csharp\">class Program \n{\n    static void Main()\n    {\n        IFigura rect = new Rect\u00e1ngulo();\n        rect.Dibuja();\n    }\n}\n</code></pre>\n<p>Cu\u00e1ndo asignamos un objeto a la referencia, en este caso <code>rect</code>, mediante\nella podemos acceder a los miembros definidos en la interfaz <code>IFigura</code>. Aunque no\nser\u00eda posible, por ejemplo, llamar al m\u00e9todo <code>ImprimeCoordenadas()</code>, que \naunque es miembro de la clase <code>Rect\u00e1ngulo</code>, no es miembro de la interfaz. </p>\n<p>En caso de ser necesario podr\u00edamos hacer una conversi\u00f3n de tipo:</p>\n<pre><code class=\"language-csharp\">class Program \n{\n    static void Main()\n    {\n\n        IFigura rect = new Rect\u00e1ngulo() {X=120, Y=100};\n        rect.Dibuja();\n\n        // Para ejecutar un m\u00e9todo miembro de Rect\u00e1ngulo \n        // debemos dereferenciar a esta clase\n        (rect as Rect\u00e1ngulo).ImprimeCoordenadas(); \n\n        // En versiones recientes de C#, nos marca un warning\n        // porque rect podr\u00eda ser nulo. En este caso podemos \n        // utilizar el operador ! para que no considere el posible error\n        (rect as Rect\u00e1ngulo)!.ImprimeCoordenadas(); \n    }\n}\n</code></pre>\n<h3>Polimorfismo</h3>\n<p>El polimorfismo se puede implementar igual que con una clase abstracta,\nasignando a <code>IFigura</code> objetos con la capacidad de dibujarse. Esto es algo\ndistinto al polimorfismo que vimos antes, el cual se basaba en la herencia, en\neste caso no es necesario que haya esta relaci\u00f3n jer\u00e1rquica entre las clases.\nPor esta raz\u00f3n, incluso ser\u00eda mejor que la clase se llamara <code>IDibujable</code>, ya\nque no tienen que ser necesariamente figuras los objetos que deseamos dibujar.</p>\n<pre><code class=\"language-csharp\">class Program \n{\n    static void Main()\n    {\n        List&lt;IDibujable&gt; objetos = new List&lt;IDibujable&gt;();\n\n        IDibujable rect = new Rect\u00e1ngulo() {X=120, Y=100};\n        (rect as Rect\u00e1ngulo)!.ImprimeCoordenadas(); \n\n        objetos.Add(rect); \n        objetos.Add(new Elipse() {X=100, Y=200}); \n        objetos.Add(new Im\u00e1gen() {X=300, Y=300}); \n\n        foreach(var o in objetos)\n            o.Dibuja(); // Cada objeto se dibuja de acuerdo a su implementaci\u00f3n \n    }\n}\n</code></pre>\n<p>Puedes completar el c\u00f3digo anteror como ejercicio personal.</p>\n<h3>M\u00faltiples implementaciones</h3>\n<p>El uso de las interfaces, m\u00e1s all\u00e1 del polimorfismo, es el establecer cierta\nfuncionalidad, la cual puede ser implementada por distintos tipos de objetos.\nPor ejemplo, la funcionalidad gen\u00e9rica para conectarse a un sistema de bases de\ndatos podr\u00eda especificarse en una interfaz. Por ejemplo: </p>\n<pre><code class=\"language-csharp\">interface IBaseDeDatos \n {\n  IConexion CreaConexi\u00f3n();  \n  ICursor ExecutaConsulta(IConexion c);\n  int CierraConexi\u00f3n();\n  }\n</code></pre>\n<p>Despu\u00e9s otros programadores podr\u00edan implementar estas interfaces con clases para distintos servidores como \nMySQL, Oracle, SQLServer, etc. </p>\n<h4>Referencias</h4>\n<p>El ejemplo utilizado es una adaptaci\u00f3n de <a href=\"https://en.wikibooks.org/wiki/C_Sharp_Programming/Interfaces\">Interfaces en C# de Wikibooks</a>  </p>"}