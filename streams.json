{"_id": "/activity/733edf66-8219-11e7-9265-3401663b8331", "uri": "/activity/733edf66-8219-11e7-9265-3401663b8331", "publisher": null, "level": "intermedio", "rights": "Attribution 4.0 International", "description": "Persistencia, Streams, Buffers", "icon": "file", "author": "Mario Garc\u00eda Valdez", "tags": ["clase", "csharp"], "image_url": null, "title": "Introducci\u00f3n a Streams", "type": "text", "external_url": "https://sfo2.digitaloceanspaces.com/evo/uno/autores/mario.jpg", "author_image": "https://sfo2.digitaloceanspaces.com/evo/uno/autores/mario.jpg", "content": "<h2>Objetos Peristentes</h2>\n<p>Un proceso es un programa en ejecuci\u00f3n. El c\u00f3digo fuente que escribimos en\nalg\u00fan lenguaje como C# o C++, se compila a c\u00f3digo ejecutable, ya sea binario o\nbytecode. Este c\u00f3digo se ejecuta como un proceso y durante su ejecuci\u00f3n se\ncrean y destruyen objetos. Cada objeto requiere de cierto espacio de memoria y\nexiste por un determinado tiempo. No obstante, una vez que el proceso termina,\ntoda la memoria que ten\u00eda asignada el proceso, se libera para ser utilizada por\notros. Esto significa que todos los objetos creados por nuestro programa se\ndestruyen. Muchas veces necesitamos mantener el estado de nuestros objetos por\nmucho tiempo, por ejemplo, en un sistema de control escolar o de comercio\nelectr\u00f3nico es necesario contar siempre con la informaci\u00f3n de los alumnos y\nnuestras compras. En estos casos necesitamos que nuestros objetos sean\npersistentes.</p>\n<p>En el modelo orientado a objetos, decimos que el estado de un objeto es\n<strong>persistente</strong>, si su estado se mantiene, aunque el proceso d\u00f3nde se cre\u00f3 haya\nterminado. Incluso, seg\u00fan la definici\u00f3n de Booch, un objeto persistente\ntrasciende el tiempo, ya que el objeto existe aun cuando la entidad que lo cre\u00f3\nhaya dejado de existir. Tambi\u00e9n se incluye como una propiedad de la\npersistencia la capacidad de trascender el espacio, pues el objeto se puede\nsalir del espacio de memoria en el que se ha creado. </p>\n<p>Normalmente, utilizamos sistemas de bases de datos relacionales u orientadas a\nobjetos, para gestionar la persistencia. Los sistemas de bases datos nos\nofrecen una soluci\u00f3n escalable y la capacidad de mantener el estado de nuestros\nobjetos consistente aun cuando m\u00faltiples procesos hagan modificaciones al mismo\ntiempo. Este es un tema que cae en otra materia, por lo que no lo abordaremos\nen este momento. Como una primera aproximaci\u00f3n al tema, vamos a utilizar archivos\npara almacenar el estado de nuestros objetos. </p>\n<p>Para leer o escribir a un archivo, primero debemos familiarizarnos con los \nconceptos de flujos (streams en ingl\u00e9s) y buffers, ya que esto nos permitir\u00e1 entender mejor\nel funcionamiento de las clases <code>StreamReader</code> y <code>StreamWriter</code> que veremos\na continuaci\u00f3n.</p>\n<h2>Streams</h2>\n<p>En computaci\u00f3n, un flujo  (en ingl\u00e9s <em>stream</em>), es una secuencia continua de\ndatos que se transmiten o procesan de manera progresiva. Al igual los art\u00edculos\nque viajan en una banda transportadora, los datos de un stream son procesados\nuno por uno. Actualmente, los servicios de streaming de videos como Netflix, en\nlugar de enviarnos el archivo completo de la pel\u00edcula que queremos ver (lo cual\npodr\u00eda tardar mucho tiempo), utilizan precisamente streams para enviarnos la\npel\u00edcula. Para esto, se divide primero el archivo en trozos (o paquetes), los\ncuales se env\u00edan a nuestro dispositivo secuencialmente, uno tras otro, y los\nvamos consumiendo a medida que llegan. El uso de streams, nos perimite procesar\npotencialmente un n\u00famero ilimitado de datos, ya que no estamos limitados por la\ncantidad de memoria disponible localmente.</p>\n<p>Nuestros programas utilizan esta misma estrategia para enviar o recibir datos a\notras entidades que est\u00e1n fuera del proceso, por ejemplo, archivos, servidores\nremotos, la terminal o  el teclado.  </p>\n<p>Los streams pueden ser de entrada o de salida, dependiendo de la direcci\u00f3n del\nflujo de datos. Por ejemplo, un stream de entrada podr\u00eda representar los datos\nque se est\u00e1n leyendo de un archivo o se est\u00e1n recibiendo desde un dispositivo\nde entrada, mientras que un stream de salida podr\u00eda representar los datos que\nse est\u00e1n escribiendo en un archivo o se est\u00e1n enviando a un dispositivo de\nsalida. </p>\n<p>Los datos fluyen desde o hacia nuestro programa desde diferentes fuentes: </p>\n<ul>\n<li>Dispositivos IO (entrada-salida) como el teclado, la consola, impresora</li>\n<li>Archivos</li>\n<li>Memoria</li>\n<li>Un socket TCP/IP</li>\n<li>Tuber\u00eda de comunicaci\u00f3n interprocesos </li>\n<li>Una conexi\u00f3n http</li>\n</ul>\n<h2>Buffers</h2>\n<p>Siguiendo el ejemplo de Netflix, para evitar que la reproducci\u00f3n de la pel\u00edcula\nse detenga cuando tenemos una conexi\u00f3n a internet intermitente, se hace uso de\nun b\u00fafer. Un b\u00fafer (buffer en ingl\u00e9s) se refiere a un \u00e1rea de memoria temporal utilizada para\nalmacenar datos antes de que sean procesados o enviados. En este caso, se\nalmacenan un b\u00fafer bloques de la pel\u00edcula conforme van llegando, y se\nreproducen constantemente los bloques ya est\u00e1n en el b\u00fafer. En caso de que el\nb\u00fafer se vac\u00ede, entonces necesitaremos esperar a que el b\u00fafer tenga datos\nsuficientes para seguir reproduciendo la pel\u00edcula. Entonces, el b\u00fafer act\u00faa\ncomo un intermediario entre la fuente de datos y el destino, permitiendo una\ntransferencia m\u00e1s eficiente y controlada de la informaci\u00f3n.</p>\n<h2>System.IO</h2>\n<p>La clase abstracta <code>Stream</code> y sus derivadas, no brindan un mecanismo abstracto \npara leer y escribir a m\u00faltiples entidades sin preocuparnos por los detalles de \nbajo nivel espec\u00edficos al sistema operativo o los dispositivos subyacentes.\nLas clases principales que heredan de <code>Stream</code> son <code>FileStream</code> y <code>MemoryStream</code>.</p>\n<p>Podemos realizar estas tres operaciones utilizando streams:</p>\n<ul>\n<li>\n<p>Podemos leer de un stream. Le llamamos lectura a transferir datos del stream \na una estructura dentro de nuestro programa como una lista o un arreglo.</p>\n</li>\n<li>\n<p>Podemos escribir a un stream. Escribir es transferir datos de un arreglo en \nnuestro programa a un stream. </p>\n</li>\n<li>\n<p>Algunos flujos pueden incluir una funcionalidad de posicionamiento (seek),\n  con la cual podemos consultar y modificar la posici\u00f3n actual del flujo.\n  Algunos flujos no tienen esta capacidad, por ejemplo, un flujo de red.</p>\n</li>\n</ul>\n<p>Para saber con qu\u00e9 capacidades cuenta el stream que estemos utilizando el momento\ndado, podemos consular las siguientes propiedades de la clase <code>Stream</code>: <code>CanRead</code>, \n<code>CanWrite</code> y <code>CanSeek</code> respectivamente.</p>\n<p>Para realizar las operaciones descritas arriba, utilizaremos los m\u00e9todos\n<a href=\"https://learn.microsoft.com/en-us/dotnet/api/system.io.stream.read?view=net-7.0\"><code>Read</code></a>\ny <a href=\"https://learn.microsoft.com/en-us/dotnet/api/system.io.stream.write?view=net-7.0\"><code>Write</code></a>. \nPor otro lado, para la b\u00fasqueda utilizaremos el m\u00e9todo <code>Seek</code> para posicionarnos en otro lugar en el stream.</p>\n<p>La clase <code>Stream</code> implementa a la interfaz <code>IDisposible</code>. Esto es necesario porque \nutilizaremos recursos que est\u00e1n fuera del proceso, y por lo, tanto no pueden \ndestruirse autom\u00e1ticamente por el <em>recolector de basura</em>. Cuando terminamos de utilizar un stream\ndebemos desecharlo impl\u00edcita o expl\u00edcitamente. Para hacerlo expl\u00edcitamente debemos de\nllamar al m\u00e9todo <code>Dispose</code> dentro de un bloque <code>try/catch</code>. Para disponerlo expl\u00edcitamente\ndebemos utilizar la construcci\u00f3n <code>using</code>.  Al eliminar un stream, se vac\u00edan los datos\nalmacenados en el b\u00fafer y se liberan los recursos del sistema operativo, red u otros. </p>\n<p>En las versiones actuales de .NET tambi\u00e9n se cuenta con clases as\u00edncronas,  esto se\nver\u00e1 en otra unidad. </p>\n<h3><code>StreamReader</code></h3>\n<p>La clase <code>StreamReader</code> nos permite leer archivos de texto. En el constructor\npasamos la ruta y nombre del archivo que vamos a leer. Podemos llamar\nal m\u00e9todo <code>ReadLine</code> para leer del archivo una l\u00ednea de texto. En caso de\nque lleguemos al fin del archivo, <code>ReadLine</code> nos regresar\u00e1 <code>null</code>.\nEn ejemplo siguiente, vemos c\u00f3mo se utiliza la construcci\u00f3n <code>using</code> para \ndesechar al objeto <code>sr</code> de manera impl\u00edcita. </p>\n<div class=\"highlight\"><pre><span></span><code><span class=\"k\">using</span><span class=\"w\"> </span><span class=\"nn\">System</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"k\">using</span><span class=\"w\"> </span><span class=\"nn\">System.IO</span><span class=\"p\">;</span><span class=\"w\"></span>\n\n<span class=\"k\">class</span><span class=\"w\"> </span><span class=\"nc\">Test</span><span class=\"w\"> </span>\n<span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">  </span><span class=\"k\">public</span><span class=\"w\"> </span><span class=\"k\">static</span><span class=\"w\"> </span><span class=\"k\">void</span><span class=\"w\"> </span><span class=\"nf\">Main</span><span class=\"p\">()</span><span class=\"w\"></span>\n<span class=\"w\">  </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">try</span><span class=\"w\"> </span>\n<span class=\"w\">    </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"c1\">// Creamos una instancia de StreamReader para leer desde un archivo.</span>\n<span class=\"w\">    </span><span class=\"c1\">// using nos permite cerrar y desecharlo de manera indirecta.</span>\n<span class=\"w\">    </span><span class=\"k\">using</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"n\">StreamReader</span><span class=\"w\"> </span><span class=\"n\">sr</span><span class=\"w\"> </span><span class=\"p\">=</span><span class=\"w\"> </span><span class=\"k\">new</span><span class=\"w\"> </span><span class=\"n\">StreamReader</span><span class=\"p\">(</span><span class=\"s\">&quot;ArchivoPrueba.txt&quot;</span><span class=\"p\">))</span><span class=\"w\"></span>\n<span class=\"w\">      </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">      </span><span class=\"kt\">string</span><span class=\"w\"> </span><span class=\"n\">line</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"w\">      </span><span class=\"c1\">// Leemos y mostramos las l\u00edneas mientras</span>\n<span class=\"w\">      </span><span class=\"c1\">// no lleguemos al final del archivo.</span>\n<span class=\"w\">      </span><span class=\"k\">while</span><span class=\"w\"> </span><span class=\"p\">((</span><span class=\"n\">line</span><span class=\"w\"> </span><span class=\"p\">=</span><span class=\"w\"> </span><span class=\"n\">sr</span><span class=\"p\">.</span><span class=\"n\">ReadLine</span><span class=\"p\">())</span><span class=\"w\"> </span><span class=\"p\">!=</span><span class=\"w\"> </span><span class=\"k\">null</span><span class=\"p\">)</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">            </span><span class=\"n\">Console</span><span class=\"p\">.</span><span class=\"n\">WriteLine</span><span class=\"p\">(</span><span class=\"n\">line</span><span class=\"p\">);</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"p\">}</span><span class=\"w\"></span>\n<span class=\"w\">      </span><span class=\"p\">}</span><span class=\"w\"> </span>\n<span class=\"w\">    </span><span class=\"p\">}</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">catch</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"n\">Exception</span><span class=\"w\"> </span><span class=\"n\">e</span><span class=\"p\">)</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">Console</span><span class=\"p\">.</span><span class=\"n\">WriteLine</span><span class=\"p\">(</span><span class=\"s\">&quot;No se pudo leer el archivo&quot;</span><span class=\"p\">);</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">Console</span><span class=\"p\">.</span><span class=\"n\">WriteLine</span><span class=\"p\">(</span><span class=\"n\">e</span><span class=\"p\">.</span><span class=\"n\">Message</span><span class=\"p\">);</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"p\">}</span><span class=\"w\"></span>\n<span class=\"w\">  </span><span class=\"p\">}</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>\n<p>En las siguientes secciones veremos c\u00f3mo leer y escribir el estado de los objetos\na archivos de texto y binarios.</p>\n<h4>Referencias</h4>\n<ul>\n<li>\n<p>Algunas partes son adaptadas del material de <a href=\"https://github.com/dotnet/docs/\">dotnet/docs</a> \ncon licencia <strong><em>Attribution 4.0 International</em></strong>, este material se comparte con la misma licencia. </p>\n</li>\n<li>\n<p>Streams en <a href=\"https://learn.microsoft.com/es-mx/dotnet/api/system.io.stream?view=net-7.0\">dotnet/docs</a></p>\n</li>\n</ul>"}