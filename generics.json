{"_id": "/activity/733edf66-8219-11e7-9241-3401663b8331", "uri": "/activity/733edf66-8219-11e7-9241-3401663b8331", "publisher": null, "level": "intermedio", "rights": "Attribution 4.0 International", "description": "Variables Polim\u00f3rficas en C#", "icon": "file", "author": "Mario Garc\u00eda Valdez", "tags": ["clase", "csharp"], "image_url": null, "title": "Generics en C#", "type": "text", "external_url": "https://sfo2.digitaloceanspaces.com/evo/uno/autores/mario.jpg", "author_image": "https://sfo2.digitaloceanspaces.com/evo/uno/autores/mario.jpg", "content": "<p>\u00bfCu\u00e1l ser\u00eda la interfaz b\u00e1sica para una colecci\u00f3n tipo lista?, podr\u00edamos \ndefinir para empezar las operaciones de agregar, leer y borrar elementos. \nUna versi\u00f3n reducida de la interfaz <code>IList</code> de <em>.NET</em> puede ser: </p>\n<pre><code class=\"language-csharp\">interface IList\n {\n  // Propiedad Count, con el n\u00famero de elementos \n  // en la lista.\n  int  Count { get; } \n\n  // Agrega un item a la lista, regresa la posici\u00f3n, o -1 si no \n  // fue posible agregar el elemento.\n  int Add (object? value);\n\n  // Borra un elemento  \n  void Remove (object? value);\n\n  // Regresa o modifica el elemento en el \u00edndice especificado\n  object? this[int index] { get; set; }\n  }\n</code></pre>\n<p>Hay varias opciones para implementar en una clase concreta esta interfaz.\nPor ejemplo, utilizando un arreglo de tama\u00f1o fijo o podr\u00edamos dise\u00f1ar una\nlista enlazada \u2013que ya es un tema para <em>Estructura de Datos</em>. En fin, en lo que \nnos vamos a enfocar de momento, es en la decisi\u00f3n de utilizar a la clase <code>Object</code>,\ncomo el tipo de dato que almacenaremos en la lista.\nEsto tiene la ventaja de que podemos almacenar cualquier tipo de objeto en la lista:</p>\n<pre><code class=\"language-csharp\">using System.Collections;\n\npublic class Program \n{\n    public static void Main() \n    {\n    ArrayList objetos = new ArrayList();\n    objetos.Add(5);\n    objetos.Add(23.3m);\n    objetos.Add(&quot;Hola&quot;);\n\n    // No es posible convertir explicitamente de object a string\n    // string? saludo = objetos[2];\n\n    // Correcto: \n    string? saludo = (string?) objetos[2];\n\n    // Warning: Unboxing de un posible valor nulo\n    int z = 10 + (int) objetos[0];\n\n    foreach(Object  o in objetos)\n      Console.WriteLine(o);\n\n    }\n}\n</code></pre>\n<p>En este caso estamos utilizando a la clase <code>ArrayList</code> la cual implementa a <code>IList</code> con \ntama\u00f1o din\u00e1mico. Vemos que podemos agregar distintos tipos de objetos, pero hay un detalle importante: \ncuando leemos los datos debemos hacer una conversi\u00f3n de tipos, de <code>Object</code> al tipo del objeto\nque almacenamos. Esto sucede tambi\u00e9n al momento en el que guardamos los datos, aunque no lo \nhagamos expl\u00edcitamente. Tambi\u00e9n debemos tener cuidado de saber exactamente en que posici\u00f3n almacenamos \nque tipo de dato. Una soluci\u00f3n a esto, ser\u00eda tener cuidado de almacenar solo objetos de un tipo.\n\u00bfQu\u00e9 opciones tenemos para aliviar este problema?. Una idea podr\u00eda ser el establecer una interfaz por\ncada tipo de dato, por ejemplo, para almacenar enteros tendr\u00edamos:</p>\n<pre><code class=\"language-csharp\">interface IList\n {\n  // Propiedad Count, con el n\u00famero de elementos \n  // en la lista.\n  int  Count { get; } \n\n  // Agrega un item a la lista, regresa la posici\u00f3n, o -1 si no \n  // fue posible agregar el elemento.\n  int Add (int? value);\n\n  // Borra un elemento  \n  void Remove (int? value);\n\n  // Regresa o modifica el elemento en el \u00edndice especificado\n  int? this[int index] { get; set; }\n  }\n</code></pre>\n<p>Y as\u00ed sucesivamente para <code>string</code>, <code>double</code>, y otras clases. Si te fijas, lo \u00fanico que \ncambiar\u00eda en las interfaces \u00a1y en las implementaciones!, ser\u00eda solamente el tipo de dato. \nPr\u00e1cticamente, podr\u00edamos hacer un <em>Find &amp; Replace</em> en el c\u00f3digo, o utilizar una plantilla \nd\u00f3nde solo cambiemos el tipo de dato. Esta tarea la evitamos utilizando interfaces, clases \ny m\u00e9todos gen\u00e9ricos.</p>\n<h3>Gen\u00e9ricos en .NET</h3>\n<p>Las clases, estructuras, interfaces y m\u00e9todos gen\u00e9ricos utilizan unos marcadores de posici\u00f3n\nespeciales \u2013llamados <strong>par\u00e1metros de tipo</strong>- los cuales despu\u00e9s son reemplazados por los tipos \nde dato espec\u00edficos que van a utilizar. Los par\u00e1metros de tipo, aparecen en aquellos lugares\ndoode se utilizar\u00eda el tipo de dato a emplear (como valores de retorno, argumentos, en los campos,\npropiedades, etc.). Por ejemplo, nuestra interfaz IList gen\u00e9rica quedar\u00eda de la siguiente manera:</p>\n<pre><code class=\"language-csharp\">interface IList&lt;T&gt;\n {\n  // Propiedad Count, con el n\u00famero de elementos \n  // en la lista.\n  int  Count { get; } \n\n  // Agrega un item a la lista, regresa la posici\u00f3n, o -1 si no \n  // fue posible agregar el elemento.\n  int Add (T? value);\n\n  // Borra un elemento  \n  void Remove (T? value);\n\n  // Regresa o modifica el elemento en el \u00edndice especificado\n  T? this[int index] { get; set; }\n  }\n</code></pre>\n<p>C\u00f3mo vemos, el nombre de la interfaz cambia, pues ahora le agregamos el\npar\u00e1metro de tipo <code>T</code>, los par\u00e1metros de tipo van entre los s\u00edmbolos <code>&lt; &gt;</code> en\nlugar de par\u00e9ntesis. Los nombres de los par\u00e1metros gen\u00e9ricos tienen el prefijo\no se llaman <code>T</code> por convenci\u00f3n.  Una vez especificado el par\u00e1metro, cambiamos\nd\u00f3nde corresponder\u00eda el tipo <code>Object</code> por <code>T</code>. </p>\n<p>A continuaci\u00f3n se muestra como podr\u00edamos utilizar la clase gen\u00e9rica <code>List&lt;T&gt;</code>\nla cual implementa a <code>IList</code>. En este caso la lista solo puede almacenar un\ntipo de dato espec\u00edfico: </p>\n<pre><code class=\"language-csharp\">using System.Collections.Generic; // No es necesario en versiones recientes\n\npublic class Program \n{\n    public static void Main() \n    {\n    List&lt;int&gt; enteros = new List&lt;int&gt;();\n    enteros.Add(5);\n    enteros.Add(15);\n    enteros.Add(25);\n\n    List&lt;string&gt; saludos = new List&lt;string&gt;();\n    saludos.Add(&quot;Hola&quot;);\n    saludos.Add(&quot;Hey&quot;);\n    saludos.Add(&quot;What's up&quot;);\n\n    string? saludo = saludos[2];\n\n    int z = 10 + enteros[0];\n\n    foreach(var saludo in saludos) // se puede utilizar var en lugar de string\n      Console.WriteLine(saludos);\n    }\n}\n</code></pre>\n<p>Al momento de crear una instancia de un objeto gen\u00e9rico, debemos especificar el tipo de \n dato que queremos utilizar, seg\u00fan nuestras necesidades. A esta le llamamos una <strong><em>clase gen\u00e9rica \n construida</em></strong>, en la cual se han reemplazado los marcadores de posici\u00f3n, por los tipos de datos \n especificados. </p>\n<h2>M\u00e9todos Gen\u00e9ricos</h2>\n<p>Podemos definir tambi\u00e9n, m\u00e9todos gen\u00e9ricos los cuales tendr\u00e1n dos listas de par\u00e1metros: una lista \nde par\u00e1metros de tipo gen\u00e9rico y otra lista de par\u00e1metros formales. Esto se muestra en el siguiente\nejemplo:</p>\n<pre><code class=\"language-csharp\">static void Swap&lt;T&gt;(ref T a, ref T b)\n{\n    T temp = a;\n      a = b;\n      b = temp;\n}\n</code></pre>\n<p>El m\u00e9todo <em>Swap</em>, nos permite intercambiar los valores de dos variables entre s\u00ed. \nPara utilizar el m\u00e9todo con dos enteros har\u00edamos lo siguiente:</p>\n<pre><code class=\"language-csharp\">    // Fragmento de c\u00f3digo\n    int x = 10;\n    int y = 1;\n\n    Swap&lt;int&gt;(ref x, ref y);\n\n    // valor de x = 1\n    // valor de y = 10\n\n</code></pre>\n<p>En este caso solo se utiliza un par\u00e1metro de tipo gen\u00e9rico. </p>\n<h3>Terminolog\u00eda</h3>\n<ul>\n<li>\n<p>Una <em>definici\u00f3n de tipo gen\u00e9rica</em> es una declaraci\u00f3n de clase, estructura o interfaz, la cual \nfunciona como una plantilla, con marcas de posici\u00f3n para los tipos de dato que contiene o utiliza.</p>\n</li>\n<li>\n<p>Los <em>par\u00e1metros de tipo gen\u00e9ricos</em> son los marcadores de posici\u00f3n empleados\n  en la definici\u00f3n de tipos o m\u00e9todos gen\u00e9ricos. Por ejemplo, una estructura\n  <a href=\"https://es.wikipedia.org/wiki/Tabla_hash\">tipo diccionario</a> como la clase\n  <code>Dictionary&lt;TKey,TValue&gt;</code> puede incluir dos par\u00e1metros de tipo gen\u00e9ricos: <code>TKey</code> y\n  <code>TValue</code>, para representar a los tipos de datos de las claves y valores\n  almacenados en el diccionario. </p>\n</li>\n</ul>\n<h3>Vista General</h3>\n<ul>\n<li>Utiliza tipos gen\u00e9ricos para maximizar el reuso de c\u00f3digo, protecci\u00f3n de\n  tipos y desempe\u00f1o.</li>\n<li>Los tipos de datos gen\u00e9ricos se utilizan sobre todo en colecci\u00f3nes de datos.</li>\n<li>Se incluyen clases gen\u00e9ricas para la mayor\u00eda de estructuras de datos que\n  utilizamos al programar.</li>\n<li>El mismo concepto en otros lenguajes tiene otros nombres: plantillas en C++,\n  con origen en la <a href=\"https://www.stroustrup.com/DnE2005.pdf\">Standar Template Library</a> (Ver 3.1 The emergence of the STL).</li>\n</ul>\n<h3>Leer</h3>\n<ul>\n<li>[Programaci\u00f3n Gen\u00e9rica] (https://en.wikipedia.org/wiki/Generic_programming#Stepanov%E2%80%93Musser_and_other_generic_programming_paradigms)</li>\n</ul>\n<h4>Referencias</h4>\n<ul>\n<li>Algunos partes son adaptadas del material de <a href=\"https://github.com/dotnet/docs/\">dotnet/docs</a> \ncon licencia <strong><em>Attribution 4.0 International</em></strong>, este material se comparte con la misma licencia. </li>\n</ul>"}