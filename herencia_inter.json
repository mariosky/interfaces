{"_id": "/activity/733edf66-8b90-11e7-9241-3401663b8331", "uri": "/activity/733edf66-8b90-11e7-9241-3401663b8331", "publisher": null, "level": "intermedio", "rights": "Attribution-ShareAlike 4.0 International", "description": "Extenci\u00f3n de interfaces con ejemplos en C#", "icon": "file", "author": "Mario Garc\u00eda Valdez", "tags": ["clase", "csharp"], "image_url": null, "title": "Extenci\u00f3n de interfaces con ejemplos en C#", "type": "text", "external_url": "https://sfo2.digitaloceanspaces.com/evo/uno/autores/mario.jpg", "author_image": "https://sfo2.digitaloceanspaces.com/evo/uno/autores/mario.jpg", "content": "<p>Las interfaces son una collecci\u00f3n de m\u00e9todos y propiedades las cuales \nestablecen la interfaz de un servicio. Podemos exteder \nlos servicios que espec\u00edfica una interfaz, agregando los que se definen \nen otra en una relaci\u00f3n parecida a la herencia. Por ejemplo, \nla interfaz <code>IFigura</code> incluye las coordenadas de su posici\u00f3n como propiedades \ny el m\u00e9todo <code>void Dibuja ()</code>.  </p>\n<pre><code class=\"language-csharp\">interface IFigura \n {\n  int  X { get; set; } \n  int  Y { get; set; } \n  void Dibuja();  \n  }\n</code></pre>\n<p>Podemos extender esta funcionalidad \npara agregar la capacidad de rotar sobre su eje, agregando primero la funcionalidad \nen su propia interfaz:</p>\n<pre><code class=\"language-csharp\">interface IRotable \n {\n  void Rota(double radianes);  \n }\n</code></pre>\n<p>Separar la funcionalidad nos va a permitir reutilizar la interfaz <code>IRotable</code> en otros \ncontextos, esto no lo podr\u00edamos hacer si incluimos la funcionalidad dentro de <code>IFigura</code>. \nPara extender a la interfaz <code>IFigura</code> utilizamos la misma sintaxis que la herencia, \nen este caso vamos a extender la funcionalidad con m\u00faltiples interfaces:</p>\n<pre><code class=\"language-csharp\">interface IFigura : IRotable, ISerializable, IImprimible\n {\n  int  X { get; set; } \n  int  Y { get; set; } \n  void Dibuja();  \n  }\n</code></pre>\n<p>Una interfaz solo puede extender a otras interfaces, no podemos incluir una clase dentro\nde la lista. </p>\n<p>Ahora, si una clase implementa a <code>IFigura</code>, deber\u00e1 implementar todos los m\u00e9todos y propiedades \nque se especifiquen en <code>IFigura</code> pero tambi\u00e9n en las interfaces que la extienden \n(<code>IRotable</code>, <code>ISerializable</code>, <code>IImprimible</code>). </p>\n<p>Veamos un ejemplo d\u00f3nde se presenta un caso particular. La clase <code>Rect\u00e1ngulo</code> implementa \ntanto a <code>IFigura</code> como a <code>IDibujable</code>, y ambas interfaces incluyen al m\u00e9todo <code>void Dibuja()</code>. </p>\n<pre><code class=\"language-csharp\">interface IDibujable\n {\n  void Dibuja();\n }\n\ninterface IRotable \n {\n  void Rota(double radianes);  \n }\n\ninterface IFigura : IRotable\n {\n  int  X { get; set; } \n  int  Y { get; set; } \n  void Dibuja();  \n  }\n\nclass Rect\u00e1ngulo: IFigura, IDibujable\n{\n\n    public double X { get; set;}\n    public double Y { get; set;}\n\n    void IFigura.Dibuja() { \n        Console.WriteLine($&quot;Se dibuja un rect\u00e1ngulo en ({X},{Y})&quot;);\n        }\n    public void Rota(double r) { \n        Console.WriteLine($&quot;Se rota el rect\u00e1ngulo {r} radianes&quot;);\n        }\n\n    void IDibujable.Dibuja() { \n        Console.WriteLine($&quot;Se dibuja un rect\u00e1ngulo&quot;);\n        }\n\n}\n</code></pre>\n<p>La ambig\u00fcedad se resuelve a\u00f1adiendo como prefijo el nombre de la interfaz correspondiente \nal momento de implementar el m\u00e9todo y eliminando el modificador de acceso <code>public</code>. En\neste caso implementamos distinta funcionalidad seg\u00fan el caso. Otra opci\u00f3n ser\u00eda implementar \nun solo <code>void Dibuja()</code> el cual se utilice en ambos casos.</p>\n<h4>Notas</h4>\n<ul>\n<li>En ocasiones se le conoce como <strong><em>herencia de interfaces</em></strong> al extender una interfaz.</li>\n</ul>"}