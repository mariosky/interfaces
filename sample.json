{"_id": "/activity/733edf66-8219-11e7-9265-3401663b8331", "uri": "/activity/733edf66-8219-11e7-9265-3401663b8331", "publisher": null, "level": "intermedio", "rights": "Attribution 4.0 International", "description": "Persistencia, Streams, Buffers", "icon": "file", "author": "Mario Garc\u00eda Valdez", "tags": ["clase", "csharp"], "image_url": null, "title": "Introducci\u00f3n a Streams", "type": "text", "external_url": "https://sfo2.digitaloceanspaces.com/evo/uno/autores/mario.jpg", "author_image": "https://sfo2.digitaloceanspaces.com/evo/uno/autores/mario.jpg", "content": "<h3>C\u00f3mo almacenar objetos a un archivo de texto</h3>\n<p>Para escribir a un archivo de texto vamos a utilizar dos clases\ncomplementarias: <code>FileStream</code> y <code>StreamWriter</code>, estas se utilizan para realizar\noperaciones de escritura en archivos en C#. Aunque ambas se pueden utilizar de\nmanera independiente , existen algunas diferencias clave entre ellas en\nt\u00e9rminos de su funcionalidad y manera de utilizarse:</p>\n<ol>\n<li>Funcionalidad:</li>\n<li>\n<p><code>FileStream</code>: es una clase que se utiliza para leer y escribir <strong>bytes</strong> en\n  un archivo. Proporciona m\u00e9todos para realizar operaciones de lectura y\n  escritura a bajo nivel manipulando los bytes. Implementa los m\u00e9todos Read,\n  Write y Seek.</p>\n</li>\n<li>\n<p><code>StreamWriter</code>: proporciona m\u00e9todos para escribir cadenas y caracteres a un\n  archivo, realizando tambi\u00e9n tareas de codificaci\u00f3n y formato. A\n  <code>StreamWriter</code> se considera una clase de nivel superior, ya que no opera a\n  nivel de bytes y por lo mismo es m\u00e1s f\u00e1cil de utilizar.</p>\n</li>\n<li>\n<p>Uso y sintaxis:</p>\n</li>\n<li>\n<p><code>FileStream</code>: Primero necesitamos crear una\n     instancia de la clase <code>FileStream</code> y especificando como par\u00e1metro el archivo con el que \n     vamos a trabajar. Luego, puedemos utilizar los\n     m\u00e9todos para leer o escribir bytes en el\n     archivo. Vemos la operaci\u00f3n a bajo nivel en el ejemplo a continuaci\u00f3n. Cuando leemos, lo hacemos\n     a un arreglo de bytes y al escribir \n     debemos especificar par\u00e1metros adicionales de posici\u00f3n y tama\u00f1o del arreglo. </p>\n</li>\n</ol>\n<p><code>csharp\n   using (FileStream fs = new FileStream(\"archivo.txt\", FileMode.Create))\n   {\n       byte[] data = Encoding.UTF8.GetBytes(\"Ejemplo\");\n       fs.Write(data, 0, data.Length);\n   }</code></p>\n<ul>\n<li>StreamWriter: Con <code>StreamWriter</code> simplemente utilizamos el m\u00e9todo <code>WriteLine</code> y pasamos \n   directamente el objeto que deseamos almacenar. De manera similar a cuando escribimos en consola\n   internamente se llama al m\u00e9todo <code>ToString</code> para grabar el texto:</li>\n</ul>\n<p><code>csharp\n   using (StreamWriter sw = new StreamWriter(\"archivo.txt\"))\n   {\n       sw.WriteLine(\"Ejemplo de texto.\");\n   }</code></p>\n<ol>\n<li>Caracter\u00edsticas adicionales:</li>\n<li><code>FileStream</code>: Como <code>FileStream</code> trabaja a nivel de bytes, nos permite realizar\n     operaciones m\u00e1s avanzadas, como leer o escribir en ubicaciones espec\u00edficas\n     del archivo utilizando el m\u00e9todo <code>Seek</code>.</li>\n<li><code>StreamWriter</code>: Nos proporciona m\u00e9todos espec\u00edficos para escribir texto, y\n     podemos especificar el formato de codificaci\u00f3n para el archivo, el uso de\n     una memoria intermedia para almacenar datos antes de escribirlos en el\n     archivo y podemos utilizar el m\u00e9todo <code>WriteLine</code>.</li>\n</ol>\n<h4>Uso de <code>FileStream</code> y <code>StreamWriter</code></h4>\n<p>Para este ejemplo vamos a utilizar <code>FileStream</code> y <code>StreamWriter</code> para almacenar en \nun archivo de texto objetos de la clase <code>Producto</code>:</p>\n<pre><code class=\"language-csharp\">class Product\n{\n    public string code;\n    public string description;\n    public decimal price;\n\n    public Product(string c, string d, decimal p)\n    {\n        code = c; description = d; price = p;\n    }\n}\n</code></pre>\n<p>La clase incluye dos campos p\u00fablicos tipo <code>string</code> y un decimal. Vamos \na crear una clase de utiler\u00eda la cual llamaremos <code>ProductDB</code>, en ella \nvamos a agregar los m\u00e9todos est\u00e1ticos para guardar y leer instancias de <code>Producto</code>\na archivos de texto.</p>\n<p>Para guardar el estado de los productos, utilizaremos una estrategia sencilla \npara separar los campos, vamos a utilizar un caracter especial como separador.\nEn este caso utilizaremos el caracter barra vertical <code>|</code>. Hay otras soluciones\nest\u00e1ndar, por ejemplo, los archivos separados por coma, pero queremos una soluci\u00f3n b\u00e1sica.</p>\n<p>A continuaci\u00f3n se muestra la implementaci\u00f3n del m\u00e9todo <code>SaveProducts</code>. Es un m\u00e9todo\nest\u00e1tico, y solo recibe como par\u00e1metro la lista con los productos que vamos a \nguardar al archivo. En esta primera prueba hemos dejado el nombre del archivo fijo (<em>hard-coded</em>) \ncomo <code>\"products.txt\"</code>, pero es mejor que este valor se reciba como par\u00e1metro (se dejar\u00e1 como ejercicio). </p>\n<pre><code class=\"language-csharp\">class ProductDB\n{\n    public static void SaveProducts(List&lt;Product&gt; products)\n    {\n        // Declaramos el FileStream fuera del bloque try \n        // para que sea visible en todo el bloque del m\u00e9todo\n        FileStream fs = null;\n        try {\n            // Instanciamos un objeto de FileStream\n            // Vamos a crear el archivo y vamos a escribir en el\n            fs = new FileStream(&quot;products.txt&quot;, FileMode.Create, FileAccess.Write);\n            // Utilizamos 'using' para que se llame a Dispose implicitamente \n            using(StreamWriter txtOut = new StreamWriter(fs, Encoding.UTF8, 512))\n            {\n                foreach (var p in products)\n                {\n                    // Escribimos una l\u00ednea con los campos de cada objeto \n                    // Separados por un '|'\n                    txtOut.WriteLine($&quot;{p.code}|{p.description}|{p.price}&quot;);\n                }\n            }\n        }\n        // Optamos por llamar explicitamete al Dispose de fs, como ejemplo\n        finally {\n            // Solo se ejecuta si la referencia no es nula\n            if (fs != null)\n                fs.Dispose();\n        }\n\n    }\n}\n</code></pre>\n<p>En el ejemplo utilizamos una instancia de <code>FileStream</code> para especificar el modo y tipo de acceso \nque utilizaremos al manipular el archivo. Esto lo especificamos utilzando las enumeraciones \n<code>FileMode</code> y <code>FileAccess</code>. </p>\n<p>Las opciones para el modo de apertura <code>FileMode</code> son: </p>\n<table>\n<thead>\n<tr>\n<th>Valor</th>\n<th>Descripci\u00f3n</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>Append</code></td>\n<td>Abre el archivo si existe y se posiciona al final de este. Si el archivo no existe, se crea uno nuevo.</td>\n</tr>\n<tr>\n<td><code>Create</code></td>\n<td>Crea un nuevo archivo. Si el archivo ya existe, se sobrescribe.</td>\n</tr>\n<tr>\n<td><code>CreateNew</code></td>\n<td>Crea un nuevo archivo. Si el archivo ya existe, se genera una excepci\u00f3n.</td>\n</tr>\n<tr>\n<td><code>Open</code></td>\n<td>Abre un archivo existente. Si el archivo no existe, se genera una excepci\u00f3n.</td>\n</tr>\n<tr>\n<td><code>OpenOrCreate</code></td>\n<td>Abre el archivo si existe. Si no existe, se crea uno nuevo.</td>\n</tr>\n<tr>\n<td><code>Truncate</code></td>\n<td>Abre un archivo existente y lo trunca a cero bytes. Si el archivo no existe, se genera una excepci\u00f3n.</td>\n</tr>\n</tbody>\n</table>\n<p>Las opciones para el tipo de acceso son <code>FileAccess.Read</code>, <code>FileAccess.Write</code> y <code>FileAccess.ReadWrite</code>, \nindicando las operaciones que vamos a hacer en el archivo. </p>\n<p>A continuaci\u00f3n se muestra otra versi\u00f3n donde se utiliza la construcci\u00f3n <code>using</code> para ambas instancias.</p>\n<pre><code class=\"language-csharp\">    public static void SaveProducts(List&lt;Product&gt; products)\n    {\n            using(FileStream fs = new FileStream(&quot;products.txt&quot;, FileMode.Create, FileAccess.Write))\n            using(StreamWriter txtOut = new StreamWriter(fs, Encoding.UTF8, 512))\n            {\n                foreach (var p in products)\n                {\n                    txtOut.WriteLine($&quot;{p.code}|{p.description}|{p.price}&quot;);\n                }\n            }\n\n    }\n</code></pre>\n<p>Para probar nuestras clases vamos a crear una lista de productos y \nllamaremos el m\u00e9todo <code>ProductDB.SaveProducts</code>.</p>\n<pre><code class=\"language-csharp\">class Program\n{\n    static void Main()\n    {\n        List&lt;Product&gt; productos = new();\n        productos.Add(new Product(&quot;AAX&quot;, &quot;Atari 2600&quot;, 190.99m));\n        productos.Add(new Product(&quot;BBX&quot;, &quot;NES&quot;, 290.99m));\n        productos.Add(new Product(&quot;CCX&quot;, &quot;Game Boy&quot;, 90.99m));\n\n        ProductDB.SaveProducts(productos);\n\n    }\n}\n</code></pre>\n<p>Al ejecutar el c\u00f3digo deber\u00edamos crear un archivo llamado <code>products.txt</code> que est\u00e1\nen la ra\u00edz del proyecto y tiene los siguientes datos:</p>\n<pre><code>AAX|Atari 2600|190.99\nBBX|NES|290.99\nCCX|Game Boy|90.99\n</code></pre>\n<h4>Referencias</h4>\n<ul>\n<li>\n<p>Algunos partes son adaptadas del material de <a href=\"https://github.com/dotnet/docs/\">dotnet/docs</a> \ncon licencia <strong><em>Attribution 4.0 International</em></strong>, este material se comparte con la misma licencia. </p>\n</li>\n<li>\n<p>Streams en <a href=\"https://learn.microsoft.com/es-mx/dotnet/api/system.io.stream?view=net-7.0\">dotnet/docs</a></p>\n</li>\n</ul>"}