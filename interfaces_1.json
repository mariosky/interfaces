{"_id": "/activity/7e30df52-8b90-11e7-9241-3401663b8331", "uri": "/activity/7e30df52-8b90-11e7-9241-3401663b8331", "publisher": null, "level": "intermedio", "rights": "Attribution-ShareAlike 4.0 International", "description": "Definici\u00f3n de interface con ejemplos en c#", "icon": "file", "author": "Mario Garc\u00eda Valdez", "tags": ["clase", "csharp", "frontpage"], "image_url": null, "title": "Interfaces en C#", "type": "text", "external_url": "https://sfo2.digitaloceanspaces.com/evo/uno/autores/mario.jpg", "author_image": "https://sfo2.digitaloceanspaces.com/evo/uno/autores/mario.jpg", "content": "<p>Vamos a imaginar que tenemos una clase abstracta, la cual tiene solo m\u00e9todos\nabstractos. Ahora, si escribimos una nueva clase que herede de nuestra clase\nabstracta \"pura\", estamos obligados a redefinir <strong>todos</strong> sus m\u00e9todos. Ser\u00eda\ncomo si estuvi\u00e9ramos firmando un contrato que nos obliga a implementar toda la\nfuncionalidad de la clase base. Justo establecer este tipo de contrato es el\nobjetivo de las interfaces. </p>\n<p>Una <strong><em>interfaz</em></strong> es una abstracci\u00f3n que agrupa cierta funcionalidad la cual\nobligatoriamente deben definir aquellas clases que la implementan. Dependiendo\ndel lenguaje, las interfaces normalmente pueden incluir solo m\u00e9todos y\npropiedades y no deben incluir datos miembros (campos en C#), por ejemplo:</p>\n<pre><code class=\"language-csharp\">interface IColeccionable \n {\n  // Funcionalidad de la interface: \n  int Titulo; // \ud83d\udca3 ERROR: No se pueden incluir campos;\n  string Categor\u00eda { get; set; } // \u2705 Se pueden \n                                 // incluir propiedades; \n  decimal GetPrecio();  \n  int ComparaCon(object? o); \n  }\n</code></pre>\n<p>En C#, indicamos que vamos a definir una interfaz con la palabra <code>interface</code>,\nseguida de su nombre. Por convenci\u00f3n, en C# nombramos a las interfaces con el\nprefijo <em>I</em> indicando que es una interface. Muchas veces tambi\u00e9n se utiliza el\nsufijo 'able' con el que indicamos que es 'capaz de' (esto es muy com\u00fan en\ningl\u00e9s). Vemos tambi\u00e9n, que al especificar el m\u00e9todo en la interfaz, no\nagregamos una implementaci\u00f3n. Tampoco debemos indicar el modificador de acceso\nporque es obligatoriamente p\u00fablico. Del mismo modo, no agregamos la palabra\n<code>abstract</code>, ya que todos los miembros de la interface deben implementarse\nobligatoriamente.</p>\n<p>Podemos utilizar interfaces para brindar un servicio a ciertas clases, siempre\ny cuando estas implementen una interfaz que nos permita completar el servicio.\nPor ejemplo, vamos a suponer que tenemos un m\u00e9todo gen\u00e9rico para ordenar una\ncolecci\u00f3n de objetos. Para poder ordenar a los objetos necesitamos establecer\nel orden comparando a un objeto contra otros. Necesitamos que los objetos\ncuenten con un m\u00e9todo que establezca la comparaci\u00f3n entre un objeto y otro.\nEsto lo podemos especificar utilizando una interfaz.  </p>\n<p>Siguiendo con el ejemplo vamos a programar una interfaz llamada <code>IComparable</code>, c\u00f3mo la\nque se incluye en el framework .net: </p>\n<pre><code class=\"language-csharp\">interface IComparable \n {\n  int CompareTo(object? o);\n }\n</code></pre>\n<p>Listo, no es muy complicado definir la interfaz, pero lo bueno est\u00e1 en los\ndetalles. Al igual que una clase, una interfaz es un bloque que agrupa la\ndefinici\u00f3n de sus miembros.</p>\n<p>En este caso, queremos indicar que las clases que implementen a <code>IComparable</code>\nson capaces de compararse contra otros objetos. Esta capacidad ser\u00e1 necesaria\npara ordenar los objetos de la lista. Para tener la funcionalidad requerida,\nlas clases deben <em>obligatoriamente</em> implementar el m\u00e9todo <code>int\nCompareTo(object o)</code>. \nSeg\u00fan el framework el entero que regresa  <code>CompareTo</code> indica el resultado de la\ncomparaci\u00f3n: </p>\n<table>\n<thead>\n<tr>\n<th>Valor de retorno</th>\n<th>Significado</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>Menor que cero</td>\n<td>La instancia actual precede al objeto especificado como par\u00e1metro de <code>CompareTo</code>.</td>\n</tr>\n<tr>\n<td>Cero</td>\n<td>La instacia actual es igual al objeto con el que se compara.</td>\n</tr>\n<tr>\n<td>Mayor que cero</td>\n<td>La instancia actual antecede al objeto.</td>\n</tr>\n</tbody>\n</table>\n<p>Otro detalle es que el argumento del m\u00e9todo es de tipo <code>object</code>, esto es\nnecesario porque no podemos anticipar el tipo de dato contra el que se har\u00e1 la\ncomparaci\u00f3n. Esto nos obliga a realizar una conversi\u00f3n de tipo para poder hacer\nla comparaci\u00f3n. M\u00e1s adelante cuando veamos tipos gen\u00e9ricos utilizaremos a la\ninterfaz  <code>IComparable&lt;T&gt;</code> la cual elimina este problema. </p>\n<p>La diferencia entre una clase abstracta <em>pura</em> y una interfaz, r\u00e1dica en el\ntipo de relaci\u00f3n que tienen con las clases que las heredan/implementan. La\nherencia indica una relaci\u00f3n Generalizaci\u00f3n/Especializaci\u00f3n, como la que hay\nentre <code>Figura</code> y <code>C\u00edrculo</code>, por otro lado, la relaci\u00f3n que tiene una clase con\nuna interfaz es de implementaci\u00f3n. Indica solamente que la clase\n<strong>implementa</strong> a la <strong>interface</strong>. Esta diferencia, permite a las clases\nimplementadas en lenguajes con herencia simple, como c#, tener la\ncapacidad de implementar m\u00faltiples interfaces.</p>\n<p>El siguiente ejemplo ilustra la implementaci\u00f3n de <code>IComparable</code> por parte de la clase \n<code>Alumno</code>, en este caso queremos ordenar a los objetos por su n\u00famero de control. </p>\n<pre><code class=\"language-csharp\">using System;\nusing System.Collections.Generic;\n\npublic class Alumno : IComparable\n{\n    public int NumControl {get; set;} \n    public string? Nombre {get; set;}\n\n    // Este m\u00e9todo es obligatorio debido a que implementamos \n    // IComparable.\n    // El argumento podr\u00eda ser nulo.\n    public int CompareTo(object? o) {\n        if (o == null) return 1;\n        // Conversi\u00f3n de tipo\n        Alumno? otroAlumno = o as Alumno;\n\n        if (otroAlumno != null)\n          // La clase Int implementa IComparable tambi\u00e9n, \n          // as\u00ed que comparamos por NumControl.\n          return this.NumControl.CompareTo(otroAlumno.NumControl);\n        else\n          throw new ArgumentException(&quot;El argumento no es tipo Alumno&quot;);\n    }\n}\n\npublic class Program \n{\n    public static void Main()\n    {\n    List&lt;Alumno&gt; alumnos = new();\n    // Insertamos algunos alumnos\n    alumnos.Add( new Alumno() {NumControl = 1201, Nombre=&quot;ana&quot;});\n    alumnos.Add( new Alumno() {NumControl = 1003, Nombre=&quot;tom&quot;});\n    alumnos.Add( new Alumno() {NumControl = 1105, Nombre=&quot;liz&quot;});\n\n    // Ordenamos la lista, esto funciona porque \n    // Alumno implementa IComparable\n    alumnos.Sort();\n\n    // Imprimimos a los alumnos para comprobar el \u00f3rden\n    foreach ( var alumno in alumnos)\n        Console.WriteLine($&quot;{alumno.NumControl} {alumno.Nombre}&quot;);\n\n    }\n}\n</code></pre>\n<h4>Notas</h4>\n<ul>\n<li>Al igual que las clases abstractas, no podemos crear objetos a partir de una interface.</li>\n<li>A partir de la versi\u00f3n 8.0 de C#, es posible definir implementaciones por defecto para los m\u00e9todos miembros de una interface. </li>\n<li>Es opcional implementar aquellos m\u00e9todos que ya tienen una implementaci\u00f3n por defecto.</li>\n</ul>"}